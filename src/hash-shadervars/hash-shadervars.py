import os
import glob
import sys
import platform
import fnmatch
from optparse import OptionParser
from ctypes import *

mod_path = os.path.normpath(os.path.dirname(os.path.abspath(__file__)) + '/../pymodules')
sys.path.append(mod_path)
from dhutil import util

# murmur hash callback function
hash_murmur32 = None

def recursive_glob(treeroot, pattern):
    results = []
    for base, dirs, files in os.walk(treeroot):
        goodfiles = fnmatch.filter(files, pattern)
        results.extend(os.path.join(base, f) for f in goodfiles)
    return results
  
def search_hash_insource(src_filepath):
    try:
        f = open(src_filepath, "r")
    except IOError as e:
        print "Error: could not open source file :", e.filename
    else:
        pos = 0
        end_pos = -1
        key = "SHADER_NAME("
        ret = []
        src = f.read()
        f.close()
        while pos != -1:
            pos = src.find(key, pos)
            if pos != -1:
                pos += len(key)
                end_pos = src.find(")", pos)
                ret.append(src[pos:end_pos])
        return ret

def make_hashdefs_code(hash_defs, hash_seed):
    code = ""
    global hash_murmur32
    for hash_def in hash_defs:
        defname = "GFX_SHADERNAME_" + hash_def
        defname_c = c_char_p(hash_def.encode("ascii", "ignore"))
        hash_value = hash_murmur32(defname_c, c_uint(len(hash_def)), c_uint(hash_seed))
        codeline = "#define {0} {1} /* {2} */".format(defname, hash_value, hash_def)
        code += codeline + "\n"
    return code
    
def write_code_tofile(header_path, code):
    header_comment = """
/***********************************************************************************
 * Copyright (c) 2013, Sepehr Taghdisian
 * All rights reserved.
 * 
 * Redistribution and use in source and binary forms, with or without modification, 
 * are permitted provided that the following conditions are met:
 *
 * - Redistributions of source code must retain the above copyright notice, 
 *   this list of conditions and the following disclaimer.
 * - Redistributions in binary form must reproduce the above copyright notice,
 *   this list of conditions and the following disclaimer in the documentation 
 *   and/or other materials provided with the distribution.
 *
 ***********************************************************************************/
 
  /**
  * Notice: This file is automatically generated with dark-hammer's 'hash-shadervars' tool
  */\n\n"""
    try:
        f = open(header_path, "w")
        f.write(header_comment)
        f.write(code)
        f.close()
    except IOError as e:
        print "Error: could not write to header", e.filename
    else:
        print "Hash data written to \"{0}\".".format(header_path)

   
def main():
    print "Dark-hammer shader hashing tool", util.VERSION
    if platform.system() == "Linux":
        libcore_path = os.path.normpath(util.get_exec_dir(__file__) + "/../../bin/libcore.so")
    elif platform.system() == "Darwin":
        libcore_path = os.path.normpath(util.get_exec_dir(__file__) + "/../../bin/libdh_core.dylib")
    elif platform.system() == "Windows":
        if "64bit" in platform.architecture():
            libcore_path = os.path.normpath(util.get_exec_dir(__file__) + \
                "/../pymodules/murmurhash-x64.dll")
        else:
            libcore_path = os.path.normpath(util.get_exec_dir(__file__) + \
                "/../pymodules/murmurhash-x86.dll")
    else:
        print "Error: unknown platform"
        sys.exit(-1)        
    
    parser = OptionParser()
    
    parser.add_option("-i", "--input", dest="inputdir", \
                      default=os.path.normpath(util.get_exec_dir(__file__) + "/../engine/"), \
                      help="source input directory")
    parser.add_option("-l", "--libhash", dest="libhash", default=os.path.abspath(libcore_path), \
                      help="hash library path")
    parser.add_option("-v", "--verbose", dest="verbose", action="store_true", default=False, \
                      help="verbose mode")
    parser.add_option("-s", "--seed", dest="seed", default=98424, help="hash seed")
    parser.add_option("-o", "--output", dest="outfile", \
                      default=os.path.normpath(util.get_exec_dir(__file__) + \
                      "/../../include/engine/gfx-shader-hashes.h"), \
                      help="output header file")
    (options, args) = parser.parse_args()

    # load libcore library and init hash_murmur32
    try:
        print "Loading dark-hammer core library:", options.libhash
        libcore = cdll.LoadLibrary(options.libhash)
    except:
        print "Error: could not load libcore library:", options.libhash
        sys.exit(-1)
    
    # setup ctypes for hash_murmur32 function
    global hash_murmur32
    hash_murmur32 = libcore.hash_murmur32
    hash_murmur32.restype = c_uint
    hash_murmur32.argtypes = [c_char_p, c_uint, c_uint] 
    
    # read source files in the input directory
    extensions = ("*.cpp", "*.c")
    source_files = []
    for ext in extensions:
        source_files.extend(recursive_glob(options.inputdir, ext))
    
    # parse and file SHADER_NAME instances
    print "Parsing C/CPP source files ..."
    hash_defs = set('')
    for source_file in source_files:
        if options.verbose:
            print source_file
        hash_defs |= set(search_hash_insource(source_file))
    
    # we have collected all hash defs, make 
    if len(hash_defs) > 0:
        code = make_hashdefs_code(hash_defs, options.seed)
    else:
        print "No shader-name instances found!"
        sys.exit(0)
    
    # write to header file
    write_code_tofile(options.outfile, code)

if __name__ == "__main__":
    main()


